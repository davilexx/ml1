# Метод парзеновского окна

В данном методе мы будем присваивать вес каждому объекту на основе расстояния от элемента, который мы классифицируем, до элемента из выборки. Классифицируемый объект будет иметь некоторую окрестность с радиусом h. Для каждого объекта и выборки считается отношение расстояние до входного объекта и радиуса окна. Далее вызывается ядерная функция, которая вычисляет вес опираясь на значение отношения.

Существует 5 ядер:

Прямоугольное ядро: ![pr_y](pr_y.gif)<br>
Треугольное ядро: ![tr_y](tr_y.gif)<br>
Ядро Епанечникова: ![ep_y](ep_y.gif)<br>
Квартическое ядро: ![kv_y](kv_y.gif)<br>
Гауссовское ядро: ![g_y](g_y.gif)<br>

Явным недостатком первых четырех ядер в том, что они не могут классифицировать точки, которые не попали в окно входного объекта. Гауссовское ядро решает эту проблему.

### Программная реализация на языке R

```R
euclideanDistance <- function(u,v) {
  sqrt(sum((u - v)^2))
}

## прямоугольное ядро
Rect <- function(r) {
  (abs(r) <= 1) * 0.5
}

## треугольное ядро
Tria <- function(r) {
  (abs(r) <= 1) * (1 - abs(r))
}

## ядро епанечникова
Epan <- function(r) {
  (abs(r) <= 1) * (1 - r^2)
}

## квартическое ядро
Quar <- function(r) {
  (abs(r) <= 1) * (1 - r^2)^2
}

## присваиваем вес каждому объекту до элемента из выборки
parsen <- function(x, z, h, F) {
  m <- dim(x)[1]
  n <- dim(x)[2]-1
  classes <- rep(0, length(names(table(x[,n+1]))))
  names(classes) <- names(table(x[,n+1]))
  ## зависимость веса от расстояния
  for(i in 1:m){
    y <- x[i, n+1]
    dist <- euclideanDistance(x[i,1:n],z)
    w <- F(dist/h)
    classes[y] <- classes[y] + w
  }
  if(sum(classes) > 0) {
    class <- names(which.max(classes))
  } else {
    class <- "unknown"
  }
  return(class)
}
```

### Прямоугольное ядро

<img src="pr_y_kk_loo.jpg">

### Треугольное ядро

<img src="tr_y_kk_loo.jpg">

### Ядро Епанечникова

<img src="ep_y_kk_loo.jpg">

### Квартическое ядро

<img src="kv_y_kk_loo.jpg">


Преимущества:
<ul>
<li>простота реализации</li>
<li>не требуется сортировка выборки</li>
<li>при правильном подборе h будет хорошее качество классификации</li>
</ul>

Недостатки:
<ul>
<li>если входной объект не попадет в окно с радиусом h, то его не возможно будет проклассифицировать</li>
<li>требуется хранить полную выборку</li>
</ul>

<a href="https://github.com/davilexx/ml1">На главную</a>
